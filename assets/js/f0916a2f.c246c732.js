(self.webpackChunkorbit_website=self.webpackChunkorbit_website||[]).push([[5174],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(n),h=r,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||o;return n?a.createElement(m,s(s({ref:t},p),{},{components:n})):a.createElement(m,s({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1930:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return d}});var a=n(2122),r=n(9756),o=(n(7294),n(3905)),s=["components"],i={title:"Getting started"},l=void 0,c={unversionedId:"getting-started",id:"version-0.15/getting-started",isDocsHomePage:!1,title:"Getting started",description:"This brief tutorial walks through using Orbit to manage data in a client-side",source:"@site/versioned_docs/version-0.15/getting-started.md",sourceDirName:".",slug:"/getting-started",permalink:"/docs/0.15/getting-started",editUrl:"https://github.com/orbitjs/orbit/edit/main/website/versioned_docs/version-0.15/getting-started.md",version:"0.15",frontMatter:{title:"Getting started"},sidebar:"version-0.15/docsSidebar",previous:{title:"Introduction",permalink:"/docs/0.15/intro"},next:{title:"Packages",permalink:"/docs/0.15/packages"}},p=[{value:"Defining a schema",id:"defining-a-schema",children:[]},{value:"Defining a source",id:"defining-a-source",children:[]},{value:"Loading and querying data",id:"loading-and-querying-data",children:[{value:"Asynchronous vs. synchronous queries",id:"asynchronous-vs-synchronous-queries",children:[]}]},{value:"Defining a backup source",id:"defining-a-backup-source",children:[]},{value:"Sync&#39;ing changes between sources",id:"syncing-changes-between-sources",children:[]},{value:"Introducing a coordinator",id:"introducing-a-coordinator",children:[]},{value:"Restoring from backup",id:"restoring-from-backup",children:[]},{value:"Communicating with a server",id:"communicating-with-a-server",children:[]},{value:"Managing state with buckets",id:"managing-state-with-buckets",children:[]}],u={toc:p};function d(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,'This brief tutorial walks through using Orbit to manage data in a client-side\napplication. Sticking with the "orbit" theme, this application will track some\nobjects orbiting in our own solar system.'),(0,o.kt)("h2",{id:"defining-a-schema"},"Defining a schema"),(0,o.kt)("p",null,"Schemas are used to define the models and relationships for an application."),(0,o.kt)("p",null,"Let's start by defining a schema for our solar system's data:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { Schema } from '@orbit/data';\n\nconst schemaDefinition = {\n  models: {\n    planet: {\n      attributes: {\n        name: { type: 'string' },\n        classification: { type: 'string' }\n      },\n      relationships: {\n        moons: { type: 'hasMany', model: 'moon', inverse: 'planet' }\n      }\n    },\n    moon: {\n      attributes: {\n        name: { type: 'string' }\n      },\n      relationships: {\n        planet: { type: 'hasOne', model: 'planet', inverse: 'moons' }\n      }\n    }\n  }\n};\n\nconst schema = new Schema(schemaDefinition);\n")),(0,o.kt)("p",null,"This schema defines two models, ",(0,o.kt)("inlineCode",{parentName:"p"},"planet")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"moon"),", as well as the attributes\nand relationships that are possible for each. A moon can have one planet, while\na planet can have many moons. By setting an ",(0,o.kt)("inlineCode",{parentName:"p"},"inverse")," for each relationship,\nwe're telling Orbit that changes to one side of the relationship should be\nreflected in the other."),(0,o.kt)("h2",{id:"defining-a-source"},"Defining a source"),(0,o.kt)("p",null,"Sources provide interfaces to access data. To ensure that they have the same\nunderstanding of data, every source in an application should share the same\nschema."),(0,o.kt)("p",null,"Let's create an in-memory store as our first data source:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import Store from '@orbit/store';\n\nconst store = new Store({ schema });\n")),(0,o.kt)("h2",{id:"loading-and-querying-data"},"Loading and querying data"),(0,o.kt)("p",null,"We can now load some data into our store and then query its contents:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const earth = {\n  type: 'planet',\n  id: 'earth',\n  attributes: {\n    name: 'Earth',\n    classification: 'terrestrial',\n    atmosphere: true\n  }\n};\n\nconst venus = {\n  type: 'planet',\n  id: 'venus',\n  attributes: {\n    name: 'Venus',\n    classification: 'terrestrial',\n    atmosphere: true\n  }\n};\n\nconst theMoon = {\n  type: 'moon',\n  id: 'theMoon',\n  attributes: {\n    name: 'The Moon'\n  },\n  relationships: {\n    planet: { data: { type: 'planet', id: 'earth' } }\n  }\n};\n\nstore.update(t => [\n  t.addRecord(venus),\n  t.addRecord(earth),\n  t.addRecord(theMoon)\n])\n  .then(() => store.query(q => q.findRecords('planet').sort('name')))\n  .then(planets => {\n    console.log(planets);\n  });\n")),(0,o.kt)("p",null,"The following output should be logged:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'[\n  {\n    type: "planet",\n    id: "earth",\n    attributes: {\n      name: "Earth",\n      classification: "terrestrial",\n      atmosphere: true\n    },\n    relationships: {\n      moons: {\n        data: [\n          { type: \'moon\', id: \'theMoon\' }\n        ]\n      }\n    }\n  },\n  {\n    type: "planet",\n    id: "venus",\n    attributes: {\n      name: "Venus",\n      classification: "terrestrial",\n      atmosphere: true\n    }\n  }\n]\n')),(0,o.kt)("p",null,"There's a lot going on here, so let's break it down."),(0,o.kt)("p",null,"First of all, each record is represented by a POJO that aligns with its\ncorresponding model definition in the schema. These representations conform with\nthe ",(0,o.kt)("a",{parentName:"p",href:"http://jsonapi.org/"},"JSONAPI")," specification. Every record has an identity\nestablished by a ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," pair. Relationship linkage is specified in a\n",(0,o.kt)("inlineCode",{parentName:"p"},"data")," object via identities."),(0,o.kt)("p",null,"In order to add records to the store, we call ",(0,o.kt)("inlineCode",{parentName:"p"},"store.update()")," and pass an array\nof operations. Passing a function to ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," provides us with a transform\nbuilder (",(0,o.kt)("inlineCode",{parentName:"p"},"t"),"), which we use to create an array of ",(0,o.kt)("inlineCode",{parentName:"p"},"addRecord")," operations."),(0,o.kt)("p",null,"Note that we added the relationship between the moon and the planet on just the\nmoon record. However, when we query the planet, we can see that the inverse\nrelationship has also been added. This is because every operation that's applied\nto the store's cache passes through a schema consistency check."),(0,o.kt)("p",null,"Let's look at how the store is queried:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"store.query(q => q.findRecords('planet').sort('name'));\n")),(0,o.kt)("p",null,"Because we pass a function to ",(0,o.kt)("inlineCode",{parentName:"p"},"query"),", Orbit provides us with a query builder\n(",(0,o.kt)("inlineCode",{parentName:"p"},"q"),") which we can use to compose a query expression. We're creating a simple\n",(0,o.kt)("inlineCode",{parentName:"p"},"findRecords")," query that's sorted by ",(0,o.kt)("inlineCode",{parentName:"p"},"name"),". Internally, query expressions are\nrepresented in an ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Abstract_syntax_tree"},"AST")," form\nthat allows for nearly limitless expressivity (the only limit being that all\nsources involved in processing a query need to understand the expressions\ninvolved)."),(0,o.kt)("p",null,"Here's an example of a more complex query that filters, sorts, and paginates:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"store.query(q => q.findRecords('planet')\n                  .filter({ attribute: 'classification', value: 'terrestrial' })\n                  .sort({ attribute: 'name', order: 'descending' })\n                  .page({ offset: 0, limit: 10 }))\n")),(0,o.kt)("h3",{id:"asynchronous-vs-synchronous-queries"},"Asynchronous vs. synchronous queries"),(0,o.kt)("p",null,"Note that ",(0,o.kt)("inlineCode",{parentName:"p"},"store.query"),' is asynchronous and thus returns results wrapped in a\npromise. This may seem strange at first because the store\'s data is "in memory".\nIn fact, if you want to just "peek" into the contents of the store\'s memory,\nyou can issue the same queries synchronously against the store\'s ',(0,o.kt)("inlineCode",{parentName:"p"},"Cache"),".\nFor example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// Results will be returned synchronously by querying the cache\nlet planets = store.cache.query(q => q.findRecords('planet').sort('name'));\n")),(0,o.kt)("p",null,'By querying the cache instead of the store, you\'re not allowing other sources to\nparticipate in the fulfillment of the query. Continue reading to understand how\nrequests to sources can be "coordinated".'),(0,o.kt)("hr",null),(0,o.kt)("p",null,"Want to experiment with some of the concepts presented so far?"),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/0vn2w7nzn?previewwindow=console"},"Part 1 of this example in CodeSandbox"),"."),(0,o.kt)("h2",{id:"defining-a-backup-source"},"Defining a backup source"),(0,o.kt)("p",null,"Our in-memory data store is quite isolated at the moment. If a scientist is\nusing our application to track their discoveries, a browser refresh might lose a\nwhole planet or moon! \ud83d\ude31"),(0,o.kt)("p",null,"Let's create a browser storage source to keep data around locally:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import IndexedDBSource from '@orbit/indexeddb';\n\nconst backup = new IndexedDBSource({\n  schema,\n  name: 'backup',\n  namespace: 'solarsystem'\n});\n")),(0,o.kt)("h2",{id:"syncing-changes-between-sources"},"Sync'ing changes between sources"),(0,o.kt)("p",null,"Every time a source is transformed, it emits a ",(0,o.kt)("inlineCode",{parentName:"p"},"transform")," event. It's simple\nto observe these events directly:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"store.on('transform', (transform) => {\n  console.log(transform);\n});\n")),(0,o.kt)("p",null,"It's possible to pipe changes that occur in one source into another via the\n",(0,o.kt)("inlineCode",{parentName:"p"},"sync")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"store.on('transform', (transform) => {\n  backup.sync(transform);\n});\n")),(0,o.kt)("p",null,"Like all mutation and query methods on sources, the ",(0,o.kt)("inlineCode",{parentName:"p"},"sync")," call returns a\npromise. If we want to guarantee that transforms can't be applied to our\nstore without also being backed up, we should return the promise in the event\nhandler:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"store.on('transform', (transform) => {\n  return backup.sync(transform);\n});\n")),(0,o.kt)("p",null,"Or more simply:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"store.on('transform', (transform) => backup.sync(transform));\n")),(0,o.kt)("p",null,"With this single line of code we've guaranteed that every change to the\nin-memory store will be sync'd with the backup IndexedDB source. Furthermore,\nwe've configured this synchronization to be \"blocking\", so that changes to the\nstore can't be made at all unless they are also backed up."),(0,o.kt)("h2",{id:"introducing-a-coordinator"},"Introducing a coordinator"),(0,o.kt)("p",null,"Orbit provides another layer of abstraction on top of direct event\nobservation and handling: a ",(0,o.kt)("inlineCode",{parentName:"p"},"Coordinator"),". A coordinator manages a set of\nsources to which it applies a set of coordination strategies."),(0,o.kt)("p",null,"A coordinator could be configured to handle the above scenario as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import Coordinator, { SyncStrategy } from '@orbit/coordinator';\n\nconst coordinator = new Coordinator({\n  sources: [store, backup]\n});\n\nconst backupStoreSync = new SyncStrategy({\n  source: 'store',\n  target: 'backup',\n  blocking: true\n});\n\ncoordinator.addStrategy(backupStoreSync);\n\ncoordinator.activate(); // returns a promise that resolves when all strategies\n                        // have been activated\n")),(0,o.kt)("p",null,"Although this might seem like an unnecessary amount of complexity compared with\nthe simple event handler, there are a number of benefits to using a coordinator:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"You can easily add preconfigured strategies, such as an event logging\nstrategy and a log truncation strategy (to keep the size of in-memory logs\nto a minimum). You can also create your own strategies and share them across\napplications.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Strategies can be activated ",(0,o.kt)("em",{parentName:"p"},"and deactivated")," all together by simply calling\n",(0,o.kt)("inlineCode",{parentName:"p"},"coordinator.activate()")," / ",(0,o.kt)("inlineCode",{parentName:"p"},"coordinator.deactivate()"),". Deactivating\nevent handlers directly requires careful tracking of handler functions, which\ncan be tedious. However, it's important to do this to avoid leaking memory.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Coordinators can share a log-level across all strategies. Sometimes you want\nto see debug info and sometimes only errors."))),(0,o.kt)("h2",{id:"restoring-from-backup"},"Restoring from backup"),(0,o.kt)("p",null,"Although we're now backing up our store to browser storage, we have not yet\nset up a process to restore that backed up data."),(0,o.kt)("p",null,"If we want our app to restore all of its data from browser storage when it\nfirst boots, we could perform the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"backup.pull(q => q.findRecords())\n  .then(transform => store.sync(transform))\n  .then(() => coordinator.activate());\n")),(0,o.kt)("p",null,"This code first pulls all the records from backup and then syncs them\nwith the main store ",(0,o.kt)("em",{parentName:"p"},"before")," activating the coordinator. In this way, the\ncoordination strategy that backs up the store won't be enabled until after\nthe restore is complete."),(0,o.kt)("p",null,"We now have an application which has data fully contained in the browser. Any\ndata that's entered can be accessed while offline and will even persist across\nbrowser refreshes."),(0,o.kt)("hr",null),(0,o.kt)("p",null,"Want to experiment more?"),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/rr0lkz3rxq??previewwindow=console"},"Part 2 of this example in CodeSandbox"),"."),(0,o.kt)("h2",{id:"communicating-with-a-server"},"Communicating with a server"),(0,o.kt)("p",null,"Most apps can't exist in the vacuum of a browser\u2014data tends to be far more\nuseful when it's shared with a server."),(0,o.kt)("p",null,"Let's say that we have a web server that conforms with the\n",(0,o.kt)("a",{parentName:"p",href:"http://jsonapi.org/"},"JSON:API")," specification. We can use Orbit's\n",(0,o.kt)("inlineCode",{parentName:"p"},"JSONAPISource")," to allow our app to communicate with that server."),(0,o.kt)("p",null,"We'll start by creating a new ",(0,o.kt)("inlineCode",{parentName:"p"},"remote")," source:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import JSONAPISource from '@orbit/jsonapi';\n\nconst remote = new JSONAPISource({\n  schema,\n  name: 'remote',\n  host: 'http://api.example.com'\n});\n")),(0,o.kt)("p",null,"Next let's add the source to the coordinator:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"coordinator.addSource(remote);\n")),(0,o.kt)("p",null,"And then we can add strategies to ensure that queries and updates made against\nthe store are processed by the remote server:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import { RequestStrategy, SyncStrategy } from '@orbit/coordinator';\n\n// Query the remote server whenever the store is queried\ncoordinator.addStrategy(new RequestStrategy({\n  source: 'store',\n  on: 'beforeQuery',\n\n  target: 'remote',\n  action: 'pull',\n\n  blocking: false\n}));\n\n// Update the remote server whenever the store is updated\ncoordinator.addStrategy(new RequestStrategy({\n  source: 'store',\n  on: 'beforeUpdate',\n\n  target: 'remote',\n  action: 'push',\n\n  blocking: false\n}));\n\n// Sync all changes received from the remote server to the store\ncoordinator.addStrategy(new SyncStrategy({\n  source: 'remote',\n  target: 'store',\n  blocking: false\n}));\n")),(0,o.kt)("p",null,"These strategies are all non-blocking, which means that the store will be\nupdated / queried optimistically without waiting for responses from the server.\nOnce the server responses are received, they will then be sync'd back with the\nstore."),(0,o.kt)("p",null,"This set of coordination strategies is certainly not yet production ready. We\nwill need exception handling in our strategies to tell Orbit how to handle\nnetwork errors (e.g. retry after X secs) as well as other types of exceptions."),(0,o.kt)("p",null,"Optimistic server requests paired with an in-browser backup can work well for\nsome kinds of applications. For other applications, it's more appropriate to use\nblocking strategies that tie the success of store requests to a successful\nround trip to the server. Still other applications might choose to mix\nstrategies, so that only certain updates are blocking (e.g. a store purchase)."),(0,o.kt)("p",null,"Orbit allows for filtering, exception handling, and more in strategies to\nenable any of these options. We'll dive deeper into these topics in the rest of\nthis guide, the API docs, and sample applications."),(0,o.kt)("h2",{id:"managing-state-with-buckets"},"Managing state with buckets"),(0,o.kt)("p",null,"At any given time, our Orbit application may have different kinds of state\nin-flight and unpersisted. This state may include tasks that are queued for\nprocessing, logs of transforms that have been applied, or other source-specific\nstate that we'd like to reify if our application was closed unexpectedly."),(0,o.kt)("p",null,'In order to persist this state, we can create a "bucket" that can be shared\namong our sources:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import LocalStorageBucket from '@orbit/local-storage-bucket';\nimport IndexedDBBucket, { supportsIndexedDB } from '@orbit/indexeddb-bucket';\n\nconst BucketClass = supportsIndexedDB() ? IndexedDBBucket : LocalStorageBucket;\nconst bucket = new BucketClass({ namespace: 'my-app' });\n")),(0,o.kt)("p",null,"Note that the above code favors using an IndexedDB-based bucket and only falls\nback to using a LocalStorage-based bucket if necessary."),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"bucket")," can be passed as a setting to any and all of our sources.\nFor instance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const backup = new IndexedDBSource({\n  bucket,\n  schema,\n  name: 'backup',\n  namespace: 'solarsystem'\n});\n\nconst store = new Store({ bucket, schema });\n")),(0,o.kt)("p",null,"Each source will use the bucket to initialize its queues, logs, and other state.\nAnd as their state changes, sources will use buckets to persist those changes."),(0,o.kt)("p",null,"Of course, buckets can also be used for ad-hoc state persistence of any kind\nby other parts of your application. The possibilities are extensive!"),(0,o.kt)("hr",null),(0,o.kt)("p",null,"That concludes a brief run-through of some of the key aspects of Orbit. Please\ncontinue reading the guides to gain a deeper understanding of how Orbit works\nand how to make the most of it."))}d.isMDXComponent=!0}}]);