(self.webpackChunkorbit_website=self.webpackChunkorbit_website||[]).push([[5442],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return m},kt:function(){return d}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=l(n),d=o,h=p["".concat(c,".").concat(d)]||p[d]||u[d]||a;return n?r.createElement(h,i(i({ref:t},m),{},{components:n})):r.createElement(h,i({ref:t},m))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1355:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return m},default:function(){return p}});var r=n(2122),o=n(9756),a=(n(7294),n(3905)),i=["components"],s={title:"Memory sources"},c=void 0,l={unversionedId:"memory-sources",id:"memory-sources",isDocsHomePage:!1,title:"Memory sources",description:"Memory sources, which come from the @orbit/memory package, have been discussed at",source:"@site/docs/memory-sources.md",sourceDirName:".",slug:"/memory-sources",permalink:"/docs/next/memory-sources",editUrl:"https://github.com/orbitjs/orbit/edit/main/website/docs/memory-sources.md",version:"current",frontMatter:{title:"Memory sources"},sidebar:"docs",previous:{title:"Coordination strategies",permalink:"/docs/next/coordination"}},m=[{value:"Cache",id:"cache",children:[{value:"Immutable data",id:"immutable-data",children:[]},{value:"Operation processors",id:"operation-processors",children:[]},{value:"Patches",id:"patches",children:[]},{value:"Querying cache data",id:"querying-cache-data",children:[]}]},{value:"Forking memory sources",id:"forking-memory-sources",children:[]}],u={toc:m};function p(e){var t=e.components,n=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Memory sources, which come from the ",(0,a.kt)("inlineCode",{parentName:"p"},"@orbit/memory")," package, have been discussed at\nlength throughout this guide already. Memory sources implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"Updatable"),",\n",(0,a.kt)("inlineCode",{parentName:"p"},"Queryable"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"Syncable")," interfaces, and are the primary interface through\nwhich developers will interact with an Orbit application."),(0,a.kt)("p",null,"Instead of re-explaining ",(0,a.kt)("a",{parentName:"p",href:"/docs/next/querying-data"},"querying")," and\n",(0,a.kt)("a",{parentName:"p",href:"/docs/next/updating-data"},"updating")," memory sources, this section explores some unique\ncapabilities of memory sources and their inner workings."),(0,a.kt)("h2",{id:"cache"},"Cache"),(0,a.kt)("p",null,"Every memory source keeps its data in memory in a ",(0,a.kt)("inlineCode",{parentName:"p"},"Cache"),", which is accessible via the\n",(0,a.kt)("inlineCode",{parentName:"p"},"memory.cache")," member."),(0,a.kt)("h3",{id:"immutable-data"},"Immutable data"),(0,a.kt)("p",null,"Caches use immutable data maps from ",(0,a.kt)("inlineCode",{parentName:"p"},"@orbit/immutable")," to store their actual\ndata. This makes it incredibly efficient to clone caches, and thus memory sources,\nwhich has benefits we'll discuss shortly."),(0,a.kt)("p",null,"The use of immutable data structures does not extend into the records\nthemselves, which are stored as simple POJOs. Therefore, it's not necessary to\nuse immutable access methods when working with records. There is some\nperformance tradeoff involved here, because individual records must be cloned\non mutation."),(0,a.kt)("h3",{id:"operation-processors"},"Operation processors"),(0,a.kt)("p",null,'Every change to a cache is observed by several "operation processors", whose job\nit is to ensure that the cache maintains its integrity and continues to conform\nto its associated schema.'),(0,a.kt)("p",null,"A single transform applied to a memory source may result in many changes being made by\noperation processors. For instance, when a record is removed, it must be\nremoved from all of its associated relationships. When a relationship with an\ninverse is removed, that inverse relationship must also be removed."),(0,a.kt)("h3",{id:"patches"},"Patches"),(0,a.kt)("p",null,"Typically you should not be applying changes directly to a cache. It's far\npreferable to apply changes to the associated memory source through its ",(0,a.kt)("inlineCode",{parentName:"p"},"update")," event."),(0,a.kt)("p",null,"However, caches can be modified via a ",(0,a.kt)("inlineCode",{parentName:"p"},"patch")," method, that takes an ",(0,a.kt)("inlineCode",{parentName:"p"},"Operation"),"\nor array of ",(0,a.kt)("inlineCode",{parentName:"p"},"Operation"),"s."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"PatchResult")," that's returned has the following signature:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"type PatchResultData = Record | RecordIdentity | null;\n\ninterface PatchResult {\n  inverse: RecordOperation[];\n  data: PatchResultData[];\n}\n")),(0,a.kt)("p",null,"All changes to a cache will be emitted as ",(0,a.kt)("inlineCode",{parentName:"p"},"patch")," events. These events include\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"Operation")," that was applied as well as any data returned."),(0,a.kt)("p",null,"Its important to recognize that ",(0,a.kt)("inlineCode",{parentName:"p"},"patch")," events will be emitted for ",(0,a.kt)("em",{parentName:"p"},"EVERY"),"\nchange, including those made by operation processors. Therefore, if you need\na high fidelity log of changes to a memory source, observe its cache's ",(0,a.kt)("inlineCode",{parentName:"p"},"patch")," events."),(0,a.kt)("h3",{id:"querying-cache-data"},"Querying cache data"),(0,a.kt)("p",null,"As has been ",(0,a.kt)("a",{parentName:"p",href:"/docs/next/querying-data"},"discussed"),", the contents of a cache can be\nqueried directly and synchronously, using the same query expressions that can be\napplied to other sources."),(0,a.kt)("p",null,"While ",(0,a.kt)("inlineCode",{parentName:"p"},"memory.query")," is asynchronous and thus returns results wrapped in a\npromise, ",(0,a.kt)("inlineCode",{parentName:"p"},"memory.cache.query")," is synchronous and returns results directly. For\nexample:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'// Results will be returned synchronously by querying the cache\nlet planets = memory.cache.query(q => q.findRecords("planet").sort("name"));\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"By querying the cache instead of the memory source, you're not allowing other\nsources to participate in the fulfillment of the query. If you want to\ncoordinate queries across multiple sources, it's critical to make requests\ndirectly on the memory source.")),(0,a.kt)("h2",{id:"forking-memory-sources"},"Forking memory sources"),(0,a.kt)("p",null,'Because caches store their data in immutable structures, cloning them is\nincredibly "cheap". It\'s possible to "fork" a memory source quickly, modify its data in\nisolation from its parent, and optionally "merge" those changes back.'),(0,a.kt)("p",null,"Let's look at an example of memory source forking and merging:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},'// start by adding two planets and a moon to the memory source\nawait memory.update(t => [\n  t.addRecord(earth),\n  t.addRecord(venus),\n  t.addRecord(theMoon)\n]);\n\nlet planets = await memory.query(q => q.findRecords("planet").sort("name"));\nconsole.log("original planets", planets);\n\n// fork the memory source\nlet forkedMemorySource = memory.fork();\n\n// add a planet and moons to the fork\nawait forkedMemorySource.update(t => [\n  t.addRecord(jupiter),\n  t.addRecord(io),\n  t.addRecord(europa)\n]);\n\n// query the planets in the forked memory source\nplanets = await forkedMemorySource.query(q =>\n  q.findRecords("planet").sort("name")\n);\nconsole.log("planets in fork", planets);\n\n// merge the forked memory source back into the original memory source\nawait memory.merge(forkedMemorySource);\n\n// query the planets in the original memory source\nplanets = await memory.query(q => q.findRecords("planet").sort("name"));\nconsole.log("merged planets", planets);\n')),(0,a.kt)("p",null,"It's important to note a few things about memory source forking and merging:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Once a memory source has been forked, the original and forked memory source's data can\ndiverge independently.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"A memory source fork can simply be abandoned without cost.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Merging a fork will gather the transforms applied since the fork point,\ncoalesce the operations in those transforms into a single new transform,\nand then update the original memory source."))),(0,a.kt)("hr",null),(0,a.kt)("p",null,"Want to experiment with memory source forking and merging?"),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/40lo886nn7?previewwindow=console"},"this example in CodeSandbox"),"."))}p.isMDXComponent=!0}}]);