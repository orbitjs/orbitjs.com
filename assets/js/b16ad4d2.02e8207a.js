"use strict";(self.webpackChunkorbit_website=self.webpackChunkorbit_website||[]).push([[3173],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),h=r,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||o;return n?a.createElement(m,i(i({ref:t},p),{},{components:n})):a.createElement(m,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4712:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var a=n(3117),r=n(102),o=(n(7294),n(3905)),i=["components"],s={title:"Data stores"},l=void 0,c={unversionedId:"data-stores",id:"version-0.15/data-stores",title:"Data stores",description:"Data stores, which come from the @orbit/store package, have been discussed at",source:"@site/versioned_docs/version-0.15/data-stores.md",sourceDirName:".",slug:"/data-stores",permalink:"/docs/0.15/data-stores",editUrl:"https://github.com/orbitjs/orbit/edit/main/website/versioned_docs/version-0.15/data-stores.md",tags:[],version:"0.15",frontMatter:{title:"Data stores"},sidebar:"version-0.15/docsSidebar",previous:{title:"Coordination strategies",permalink:"/docs/0.15/coordination"}},p=[{value:"Cache",id:"cache",children:[{value:"Immutable data",id:"immutable-data",children:[],level:3},{value:"Operation processors",id:"operation-processors",children:[],level:3},{value:"Patches",id:"patches",children:[],level:3},{value:"Querying cache data",id:"querying-cache-data",children:[],level:3}],level:2},{value:"Forking stores",id:"forking-stores",children:[],level:2}],d={toc:p};function u(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Data stores, which come from the ",(0,o.kt)("inlineCode",{parentName:"p"},"@orbit/store")," package, have been discussed at\nlength throughout this guide already. Stores implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"Updatable"),",\n",(0,o.kt)("inlineCode",{parentName:"p"},"Queryable"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"Syncable")," interfaces, and are the primary interface through\nwhich developers will interact with an Orbit application."),(0,o.kt)("p",null,"Instead of re-explaining ",(0,o.kt)("a",{parentName:"p",href:"/docs/0.15/querying-data"},"querying")," and\n",(0,o.kt)("a",{parentName:"p",href:"/docs/0.15/updating-data"},"updating")," stores, this section explores some unique\ncapabilities of stores and their inner workings."),(0,o.kt)("h2",{id:"cache"},"Cache"),(0,o.kt)("p",null,"Every store keeps its data in memory in a ",(0,o.kt)("inlineCode",{parentName:"p"},"Cache"),", which is accessible via the\n",(0,o.kt)("inlineCode",{parentName:"p"},"store.cache")," member."),(0,o.kt)("h3",{id:"immutable-data"},"Immutable data"),(0,o.kt)("p",null,"Caches use immutable data maps from ",(0,o.kt)("inlineCode",{parentName:"p"},"@orbit/immutable")," to store their actual\ndata. This makes it incredibly efficient to clone caches, and thus stores,\nwhich has benefits we'll discuss shortly."),(0,o.kt)("p",null,"The use of immutable data structures does not extend into the records\nthemselves, which are stored as simple POJOs. Therefore, it's not necessary to\nuse immutable access methods when working with records. There is some\nperformance tradeoff involved here, because individual records must be cloned\non mutation."),(0,o.kt)("h3",{id:"operation-processors"},"Operation processors"),(0,o.kt)("p",null,'Every change to a cache is observed by several "operation processors", whose job\nit is to ensure that the cache maintains its integrity and continues to conform\nto its associated schema.'),(0,o.kt)("p",null,"A single transform applied to a store may result in many changes being made by\noperation processors. For instance, when a record is removed, it must be\nremoved from all of its associated relationships. When a relationship with an\ninverse is removed, that inverse relationship must also be removed."),(0,o.kt)("h3",{id:"patches"},"Patches"),(0,o.kt)("p",null,"Typically you should not be applying changes directly to a cache. It's far\npreferable to apply changes to the associated store through its ",(0,o.kt)("inlineCode",{parentName:"p"},"update")," event."),(0,o.kt)("p",null,"However, caches can be modified via a ",(0,o.kt)("inlineCode",{parentName:"p"},"patch")," method, that takes an ",(0,o.kt)("inlineCode",{parentName:"p"},"Operation"),"\nor array of ",(0,o.kt)("inlineCode",{parentName:"p"},"Operation"),"s."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"PatchResult")," that's returned has the following signature:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"type PatchResultData = Record | RecordIdentity | null;\n\ninterface PatchResult {\n  inverse: RecordOperation[],\n  data: PatchResultData[]\n}\n")),(0,o.kt)("p",null,"All changes to a cache will be emitted as ",(0,o.kt)("inlineCode",{parentName:"p"},"patch")," events. These events include\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"Operation")," that was applied as well as any data returned."),(0,o.kt)("p",null,"Its important to recognize that ",(0,o.kt)("inlineCode",{parentName:"p"},"patch")," events will be emitted for ",(0,o.kt)("em",{parentName:"p"},"EVERY"),"\nchange, including those made by operation processors. Therefore, if you need\na high fidelity log of changes to a store, observe its cache's ",(0,o.kt)("inlineCode",{parentName:"p"},"patch")," events."),(0,o.kt)("h3",{id:"querying-cache-data"},"Querying cache data"),(0,o.kt)("p",null,"As has been ",(0,o.kt)("a",{parentName:"p",href:"/docs/0.15/querying-data"},"discussed"),", the contents of a cache can be\nqueried directly and synchronously, using the same query expressions that can be\napplied to other sources."),(0,o.kt)("p",null,"While ",(0,o.kt)("inlineCode",{parentName:"p"},"store.query")," is asynchronous and thus returns results wrapped in a\npromise, ",(0,o.kt)("inlineCode",{parentName:"p"},"store.cache.query")," is synchronous and returns results directly. For\nexample:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// Results will be returned synchronously by querying the cache\nlet planets = store.cache.query(q => q.findRecords('planet').sort('name'));\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"By querying the cache instead of the store, you're not allowing other\nsources to participate in the fulfillment of the query. If you want to\ncoordinate queries across multiple sources, it's critical to make requests\ndirectly on the store.")),(0,o.kt)("h2",{id:"forking-stores"},"Forking stores"),(0,o.kt)("p",null,'Because caches store their data in immutable structures, cloning them is\nincredibly "cheap". It\'s possible to "fork" a store quickly, modify its data in\nisolation from its parent, and optionally "merge" those changes back.'),(0,o.kt)("p",null,"Let's look at an example of store forking and merging:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'// start by adding two planets and a moon to the store\nawait store.update(t => [\n  t.addRecord(earth),\n  t.addRecord(venus),\n  t.addRecord(theMoon)\n]);\n\nlet planets = await store.query(q => q.findRecords("planet").sort("name"));\nconsole.log("original planets", planets);\n\n// fork the store\nlet forkedStore = store.fork();\n\n// add a planet and moons to the fork\nawait forkedStore.update(t => [\n  t.addRecord(jupiter),\n  t.addRecord(io),\n  t.addRecord(europa)\n]);\n\n// query the planets in the forked store\nplanets = await forkedStore.query(q => q.findRecords("planet").sort("name"));\nconsole.log("planets in fork", planets);\n\n// merge the forked store back into the original store\nawait store.merge(forkedStore);\n\n// query the planets in the original store\nplanets = await store.query(q => q.findRecords("planet").sort("name"));\nconsole.log("merged planets", planets);\n')),(0,o.kt)("p",null,"It's important to note a few things about store forking and merging:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Once a store has been forked, the original and forked stores' data can\ndiverge independently.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A store fork can simply be abandoned without cost.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Merging a fork will gather the transforms applied since the fork point,\ncoalesce the operations in those transforms into a single new transform,\nand then update the original store."))),(0,o.kt)("hr",null),(0,o.kt)("p",null,"Want to experiment with store forking and merging?"),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"https://codesandbox.io/s/40lo886nn7?previewwindow=console"},"this example in CodeSandbox"),"."))}u.isMDXComponent=!0}}]);